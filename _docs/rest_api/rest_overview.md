---
title: Введение
permalink: rest_overview.html
sidebar: evorest
tags: []
product: REST API
---

# Evotor RESTful API Guidelines

# Для кого это всё?

Для разработчиков как внутреннего так и публичного API Эвотор, а также внешних потребителей нашего API.

# А зачем?

Мы хотим:

- дать внешним разработчикам и партнерам гибкий и удобный API - чтобы разрабатывать было легко и удобно
- стандартизировать правила проектирования, потому что порядок лучше хаоса
- экономить время на проектировании, пользуясь готовыми гайдлайнами и продуманными шаблонами - чтобы создавать ещё больше отличных инструментов для разработчиков
- унифицировать практики разработки API внутри нашей компании - чтобы было чем хвастаться на конференциях :)

# Оформление документа

Для вещей, которые ещё не описаны, ставим пометку __`::TODO::`__.

Правила, которые ещё обсуждаются и не закреплены, - выделяем красным цветом шрифта.

__`::TODO::`__ _узнать как в GitLab Markdown использовать цвет_

Примеры данных и фрагменты кода форматируем `моноширинным шрифтом`.

Переменные для подстановки (placeholders) обозначаем как `:your_variable`.

__`::TODO::`__ Дополнять правила по мере приближения к публичной версии документа.

# Источники информации

1. [*Zalando Guidelines*](http://zalando.github.io/restful-api-guidelines/)
1. [*Github REST API v3*](https://developer.github.com/v3/)
1. [*RFC 2617: HTTP Authentication: Basic and Digest Access Authentication*](https://tools.ietf.org/html/rfc2617)
1. [*Letter cases*](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles)

__`::TODO::`__ По мере наполнения документа, будем помещать сюда ссылки на авторитетные источники, к которым мы обращались в процессе составления правил.

# Ключевые слова требований

Ключевые слова "ДОЛЖЕН", "НЕ ДОЛЖЕН", "ТРЕБУЕТСЯ", "МОЖЕТ", "НЕ МОЖЕТ", "СЛЕДУЕТ", "НЕ СЛЕДУЕТ", "РЕКОМЕНДУЕТСЯ" и "ОПЦИОНАЛЬНО" в данном документе интерпретируются в соответсвии с [*RFC 2119*](https://tools.ietf.org/html/rfc2119).

# Методические рекомендации (Guidelines)

## Авторизация

В качестве механизма авторизации рекомендуется использование `oAuth`.

Заголовок авторизации должен иметь вид:

`Authorization: Bearer :token`

Согласно `RFC 2617`, Bearer указывает тип токена.

Длина `:token` не ограничена, но рекомендуется использовать значения не длиннее 1024 символов.

__`::TODO::`__ Publisher access token, User access token, получение access token, обновление ключа, отзыв ключа.

## Именование сущностей

В названии сущностей нельзя использовать существительные, которые не имеют множественного числа (должны быть исчисляемыми).

## Проектирование схем данных

Если выполнение запроса подразумевает передачу в запросе или в ответе тела - оно должно быть представлено в виде объекта и не может быть представлено в виде коллекции.

В случаях, когда запрос или ответ не требует наличия тела - оно может отсутствовать.

Ключи в схемах объектов должны именоваться согласно snake\_case.

Все значения enum должны быть представлены в SCREAMING\_SNAKE\_CASE.

Если в корне тела запроса или ответа требуется передать коллекцию данных, она должна быть представлена в ключе items.

## Типы содержимого

Если запрос подразумевает передачу данных в теле запроса, то в заголовке
Content-Type должна быть указана схема передаваемых данных.

_Пример_:

`Content-Type: 'application/vnd.evotor.v2+json'`

Если ответ на запрос подразумевает передачу данных в теле ответа, то в заголовке `Accept` запроса должна быть указана ожидаемая схема для ответа.

_Пример 1 (для синхронного API)_:

`Accept: 'application/vnd.evotor.v2+json'`

_Пример 2 (для реактивного API)_:

`Accept: 'application/vnd.evotor.v2+stream+json'`

__`::TODO::`__ Нынешняя реализация Spring Web MVC (ReactiveTypeHandler) не поддерживает типы потоков (streams), отличные от `'application/stream+json'`

## Rate Limits

При необходимости реализовать логику ограничения доступа к ресурсам, к ответам добавляются следующие заголовки:

- `X-RateLimit-Limit` - максимальное количество запросов, которые клиент API может сделать за временной интервал;
- `X-RateLimit-Remaining` - количество запросов, оставшихся в текущем временном интервале;
- `X-RateLimit-Reset` - время, в секундах, оставшееся до начала нового временного интервала.

Каждый выполняемый запрос сокращает остаток лимита (`X-RateLimit-Remaining`).

При превышении доступного лимита, запрос будет отклонен со статусом `429 Rate Limit Exceeded`.

Чтобы запрос был успешно выполнен после превышения лимита, - необходимо дождаться наступления нового временного интервала.

## Постраничная навигация

В случае, если работа с ресурсом подразумевает получение клиентом API коллекции данных, должна быть поддержана постраничная выгрузка данных:

```json
{
  "items" : [ ... ],
  "paging": {
    "next_cursor": "string" // base64-encoded cursor value
  }
}
```

Содержимое коллекции передается в массиве `items`.

Данные о постраничной навигации передаются в теле ответа, в объекте `paging`.

Указатель (курсор) для постраничной навигации именуется как `next_cursor`.

### Первый запрос

Первый запрос к ресурсу, когда курсор еще не сформирован, определяется специфичным для ресурса контрактом и рекомендациями для частных случаев.

Контракт для query-параметров должен поддерживать query-параметры, описанные ниже. Помимо этого, допускается использование любых других параметров.

__Случай I. Time-based paging__

Если запрашиваемые ресурсы подразумевают упорядоченность по времени, то для первого запроса рекомендуется использовать следующий контракт query-параметров:
* `since` - начало временного интервала (включительно);
* `until` - конец временного интервала (не включительно).

При этом `since < until`.

__`::TODO::`__ при необходимости листать данные в обратном порядке (от конца к началу) - внедрим сортировку.

__Случай II. General cursor paging__

Если ресурсы не подразумевают какую-либо упорядоченность по времени, то допускается использование запроса без явного указания каких-либо query-параметров.

### Второй и последующие запросы

Начиная со второго запроса, единственным допустимым query-параметром является указатель для постраничной навигации, который передается в query-параметре `cursor`.

Другие переданные параметры должны быть проигнорированы.

Значение указателя должно содержать в себе зашифрованные значения параметров, указанных в первом запросе.

Рекомендуемый способ формирования значения указателя: `Base64(json_string)`.

Рекомендуется подписывать созданный курсор с целью гарантировать его оригинальность. В противном случае реализация должна брать на себя обязанность по валидации всех параметров полученного курсора.

### Последняя страница

Если следующая страница навигации отсутствует, `paging` принимает пустое значение:

```json
{
  "items" : [ ... ],
  "paging": { }
}
```

### Общие рекомендации

1. Рекомендуемый размер страницы - 1000 элементов
1. Рекомендуется при реализации поддержать непубличный параметр `limit`, определяющий количество элементов на странице

### Lessons Learned

Поддержка постраничной навигации с возможностью указания номера страницы (offset) в запросе является опциональной в силу следующих причин:
1. изучение сценариев взаимодействия client-server и server-server, используемых нашими партнерами, на примерах облачных товароучетных систем и "толстых" клиентов товароучетного ПО (наподобие 1С), показало, что такой вид навигации не востребован при интеграции с нашим Облаком;
1. современные мобильные интерфейсы в своем большистве не используют отображение элементов с возможностью перехода на конкретную страницу коллекции (востребована в основном динамическая подгрузка содержимого по принципу _swipe to load next_).

## Проектирование URI

Ресурсом может быть одиночный объект или коллекция объектов.

### Общие положения

1. В URI нельзя указывать глаголы
1. В URI нельзя перечислять подряд несколько коллекций
1. Именование элементов в URI должно выполняться в нотации kebab-case (a.k.a. spinal case).
1. Именование query-параметров должно выполняться в нотации snake\_case
1. Не допускается использование символа `/` как последнего символа URI (trailing slashes)

Пример 1:

Не правильно: `GET /products/tasks`

Правильно: `GET /products/:product-id/tasks`

Пример 2:

Не правильно: `GET /products/delete`

Правильно: `DELETE /products`

### Использование методов

|        | /resources/:resource_id     | /resources                             |
|--------|-----------------------------|----------------------------------------|
| GET    | Значение ресурса            | Страница ресурсов                      |
| POST   | Запрещено                   | Создание ресурса                       |
| PUT    | Создание/замена ресурса     | Запрещено                              |
| PATCH  | Частичное изменение ресурса | __`::TODO::`__                         |
| DELETE | Удаление ресурса            | Полное или частичное удаление ресурсов |

### Симуляция HTTP-методов

На случай, если клиент API не поддерживает работу с некоторыми HTTP-методами, допускается применение [симуляции HTTP-методов](https://www.hanselman.com/blog/HTTPPUTOrDELETENotAllowedUseXHTTPMethodOverrideForYourRESTServiceWithASPNETWebAPI.aspx)  при помощи заголовка `X-HTTP-Method-Override`.

#### Использование DELETE

__Удаление одного элемента коллекции__

`DELETE /resources/:resource_id`

__Множественное удаление элементов коллекции__

Рекомендуемое максимальное количество элементов к удалению за раз - 100.

Вариант 1:

`DELETE /resources?id=1,2,3`

##### Lessons Learned

Вариант 2:

Формируем выборку:

`POST /resources/selection`

```json
{"id": 123}
```

Удаляем выборку:

`DELETE /resources/selection/123`

Вариант 3:

__`::TODO::`__ Доработать PATCH, чтобы им можно было делать удаление

```json
[
    {
        "op": "replace",
        "path": "baz",
        "value": "boo"
    },
    {
        "op": "add",
        "path": "hello",
        "value": [
            "world"
        ]
    },
    {
        "op": "remove",
        "path": "foo"
    }
]
```

## Использование PUT

Запросы с методом PUT используются для создания или замены единицы ресурса (экземпляра сущности) __целиком__.

То есть, при отправке через PUT экземпляра сущности, сервер может:
* создать новый экземпляр (если объекта с таким id ещё нет) и ответить `201 Accepted`;
* заменить содержимое существующего экземпляра (если объект с таким id уже был создан ранее) и ответить `200 OK`.

Семантика PUT полностью соответствует описанию Zalando:
[*https://zalando.github.io/restful-api-guidelines/\#put*](https://zalando.github.io/restful-api-guidelines/#put)

Пример:

`PUT /resources/:resource-id`

## Использование POST

Создание элементов коллекции может быть выполнено при помощи метода POST.

Повторная отправка запроса с идентичными данными должна приводить к конфликту (`409 Conflict`).

Данный метод должен применяться к URI коллекции.

### Создание одного элемента коллекции

Пример:

`POST /resources`

### Создание нескольких элементов коллекции

Если в проектируемом RESTful API требуется обеспечить возможность для массового создания элементов в коллекции, то рекомендуется реализовать соответствующий bulk-метод.

Данный метод принимает POST-запросы и принимает на вход коллекции данных.

Логика обработки bulk может быть либо синхронной, либо асинхронной.

__`::TODO::`__ __Описание bulk-методов нужно провести через дополнительное ревью.__

#### Асинхронная обработка bulks

Пример:

`POST /stores/:store-id/product-bulks`

```json
{
    "items": [ ... ]
}
```

`HTTP/1.1 202`

`Location: /stores/:store-id/product-bulks/:product-task-id`

В ответе клиент API получает HTTP-статус `202 Accepted` и заголовок `Location`, содержащий URI, по которому можно узнать состояние задачи.

Далее клиент API выполняет GET-запрос к данному URI и узнает состояние обработки данных.

Пример:

`GET /stores/:store-id/product-bulks/:product-task-id`

`HTTP/1.1 200`

```json
{
    "id": "string", // :product-task-id
    "status": "RUNNING", // enum: "COMPLETED", "ACCEPTED", "RUNNING", "FAILED"
    "modified_at": "string", // unix timestamp millis,
    "errors": [], // optional
    "details": [] // optional   
}
```

В возвращаемом ответе должна присутствовать дополнительная информация о статусе выполнения задачи.
Задачи условно можно разделить на два типа: требуется ли задаче вернуть пользователю некую полезную нагрузку при успешном выполнении или нет.
К первому типу можно отнести задачу удаленного вызова процедуры (_remote rpc_), а ко второму - загрузку изображения на сервер (_fire and forget_).
Для задач первого типа рекомендуется использовать поле _details_, содержащее полезную нагрузку.
Для задач второго типа рекомендуется использовать поле _errors_ с указанием возникших ошибок.

Для асинхронных задач, требующих множественного выполнения (загрузка нескольких картинок, вызов нескольких процедур),
подразумевается, что _details_ содержит информацию обо всех выполнениях, как удачных, так и неудачных; _errors_ может содержать информацию только о неуспешных выполнениях.

#### Синхронная обработка bulks

__`::TODO::`__

## Использование PATCH

Для изменения отдельных атрибутов в экземплярах ресурса применяется метод PATCH.

В теле запроса передаются только данные, подлежащие изменению.

__Изменение одного элемента коллекции__

Данный метод должен применяться к URI экземпляра ресурса (не коллекции).

Пример:

`PATCH /resources/:resource-id`

```json
{
    "name": "foo",
    "quantity": "bar"
}
```

__`::TODO::`__ __Множественное изменение элементов коллекции__

Данный метод должен применяться к URI коллекции.

`PATCH /resources`

```json
{
    "id_1": {
        "name": "new name",
    },
    "id_2": {
        "price": 1000,
        "quantity": 100
    }
}
```

## Ответы

### Статус ответа 200

Выполнение **синхронной** операции удачно и конечно.

__`::TODO::`__ В теле ответа можно вернуть состояние ресурса.

### Статус ответа 201

Если выполнение **синхронной** операции удачно и конечно, а реализация не хочет ничего возвращать в ответе, - в теле ответа должен присутствовать заголовок `Location`.

Если делался запрос на операцию с одним элементом - то в ответе должен присутсвовать заголовок `Location` со ссылкой на этот элемент: `/resources/:resource-id`

Если запрос выполнялся на коллекцию, то `Location`: `/resources`.

### Статус ответа 202

Асинхронное выполнение операции.

Пример:

>Запрос запускает бизнес-логику на изменение тарифа клиента.
>Процесс был запущен в момент выполнения запроса, но ещё не завершился.
>В таком случае, в ответе возвращается промежуточный статус и id задачи, по которому возможно дальше узнать статус.

В ответе должен присутствовать заголовок `Location` со значением `/resource-tasks/:task-id`

#### Lessons Learned

Location: /resources/tasks/task-id (не RESTful URL)

Location: /resource-tasks/task-id (наиболее предпочтительный вариант)

Location: /tasks/task-id (не масштабируется)

Location: /queue/id (слишком generic; не RESTful; не масштабируется)

### Статус ответа 403

__`::TODO::`__

Пример:

`GET /stores/wrong-store-id/products/wrong-product-id`

`403 (no access: store-id)`

### Статус ответа 404

__`::TODO::`__

Пример:

`GET /stores/correct-store-id/products/wrong-product-id`

`404 (not found: product-id)`

### Статус ответа 5xx

__`::TODO::`__

HTTP-статусы `5xx` не допустимы при любых ответах.

## Протокол ошибок

__`::TODO::`__ __Этот раздел нуждается в Peer Review__

Старая версия протокола, согласованная с Накрайниковым/Михайловым/Петровым в сентябре 2016 года:
[*тут*](https://docs.google.com/spreadsheets/d/1IjU_nhlUYiQEek_gw_2PcmdEYXSZwgOy7WVPXZM54PM/edit?usp=sharing)

### Требования к протоколу

#### В общем

Протокол ошибок должен отвечать на 3 вопроса:
* Что я делал?
* Что не так?
* Как это исправить?

#### В частности

Протокол ошибок должен:

* Быть общим для всех обработчиков ошибок всех ресурсов RESTful API (system-wide)
* Поддерживать обработку ошибок следующих типов:
    * ошибки авторизации (code: 1000-1999)
    * ошибки аутентификации (code: 1000-1999)
    * синтаксические ошибки (code: 2000-2999)
    * ошибки модели данных (code: 2000-2999)
    * ошибки бизнес-логики (code: 3000-3999)

* Иметь схему данных, которая позволяет определить действие, которое было выполнено с ошибкой (__Что я делал?__):

    Для этого, в модели ответа стоит предусмотреть поля `requested_uri` и `http_method` (__???__)

* Иметь схему данных, которая позволяет клиенту API однозначно определить суть проблемы и дальнейшие действия для её решения сейчас или предотвращения в будущем:

    * Несколько ошибок для одного или разных экземпляров одной или разных сущностей в одном сообщении об ошибке

    * Машинная обработка ошибок:

        Поле `body.errors.item.code::string` должно содержать уникальный код ошибки, который трактуется однозначно

    * Ручная обработка ошибок:

        Объект `body.errors.item` должен содержать информацию, достаточную для локализации причины проблем разработчиком клиента API

    * Инструкции для решения проблемы:

        Объект `body.errors.item` должен содержать ссылку на ресурс с подробным описанием проблемной ситуации, причин её возникновения и путей устранения

        Например, поле `link` = https://developer.evotor.ru/docs/api/errors\#12345
    * Визуализация ошибок конечному пользователю:

        Клиент API должен иметь возможность отобразить конечному пользователю сообщение о проблеме на основе описания ошибки

        Объект `body.errors.item` должен содержать текстовое человекопонятное описание для возникшей проблемы

        Например, поле `message` с общим описанием ситуации

#### Под вопросом

__Имеет ли смысл приводить `requested_uri` и `http_method` в теле ошибки?__

Эта информация всегда есть в заголовках ответа?

__Как отличить ошибку бизнес-логики от ошибки схемы данных?__

`error.code`: EVO:\[INVENTORY\|MARKET\|CORE\]:\[AUTH\|SYNTAX\|SCHEMA\|BUSINESS\]:12345

или

`error.issue_type`: [auth,syntax,schema,business\] ?

__error.code: строка с числом или текстом?__

Числа:
1. номер по порядку: ни к чему не обязывают, но непонятны
1. нумерация по блочной системе, где первый блок - тип проблемы, второй блок - домен проблемы, третий блок - код детализации проблемы

Текст - (можно сделать чтобы был) человекопонятен, но требует логики организации и поменять на ходу нейминг будет нельзя

__Что насчет модели данных для ошибок бизнес-логики?__

Там может быть \_что\_угодно\_, и формализовать это нельзя.

Выглядит как "нужен объект `data`, в который подсистема будет писать то, что она сама хочет"

### Пример обработки ошибок

Запрос:

`POST /stores/:store_id/product-groups`

```json
{
    "id": "6DEA31DBDDA84C41BBC1DE4093551815",
    "name": "",
    "parent_id: "32a6860d-2c15-4b10-a3a8-9bd5443de230"
}
```

Ответ:

>В схеме объекта ошибки обязательными являются только поля code и link. Все остальные поля опциональны

>error.value не рекомендуется использовать в общем случае, но допустимо, если без него не обойтись при трактовке ошибки

>В ошибках валидации поле subject обязательно

Валидация тела, заголовков и query-параметров - разные code
При валидации тела - обязателен subject

Базовая модель subject reason code и link

```json
{
    "errors": [
        { // error instance
            // "entity_id": "", // undefined, optional !for bulks!
            "entity_type": "product-group", !for bulks!
            "subject": ".id", // json path compatible
            "reason": "Incorrect data type. Expected: type: string, presentation: uuid4",
            "code": "123",
            "link": "https://developer.evotor.ru/docs/api/errors",
            // "data": {} // undefined, optional
        },
        {
            // "entity_id": "", // undefined, optional
            "entity_type": "product-group",
            "subject": "name",
            "reason": "Out of range. Expected: minLength=1, maxLength=128",
            "code": "1234",
            "link": "https://developer.evotor.ru/docs/api/errors",
            // "data": {} // undefined, optional
        }
    ]
}
```

### Примеры реализации

[*https://www.twilio.com/docs/api/errors*](https://www.twilio.com/docs/api/errors) 🤟

[*https://www.twilio.com/docs/usage/troubleshooting/debugging-your-application*](https://www.twilio.com/docs/usage/troubleshooting/debugging-your-application)

[*http://zalando.github.io/problem/constraint-violation/*](http://zalando.github.io/problem/constraint-violation/)

[*https://developers.facebook.com/docs/marketing-api/error-reference*](https://developers.facebook.com/docs/marketing-api/error-reference)

[*https://developer.github.com/v3/\#client-errors*](https://developer.github.com/v3/#client-errors)

[*https://developer.twitter.com/en/docs/ads/general/guides/response-codes*](https://developer.twitter.com/en/docs/ads/general/guides/response-codes)

[*https://vk.com/dev/errors*](https://vk.com/dev/errors)

[*https://apiok.ru/dev/errors*](https://apiok.ru/dev/errors) 😵

## Webhooks

__`::TODO::`__

## Events Streaming

__`::TODO::`__

## oAuth

## Доступ к данным

Доступная модель ресурса меняется, в зависимости от scope-ов приложения.

__`::TODO::`__

__Остатки vs Товары:__
* доступная модель ресурса products меняется в зависимости от заданных
extpoint
* если есть права на запись products:
    * можешь писать в базовую сущность product (без quantity)
* если есть права на запись quantity:
    * можешь писать только в product/quantity
* если есть права на запись product+quantity:
    * можешь писать в products полную сущность product\'а, включая quantity

__Переход на скоупы:__
* новый сервис для scopes
* постепенный уход от ext\_points в сторону: rest.scopes, app.settings,
webhooks\|events

## Прочие ограничения и правила

Формирование идентификаторов сущностей, которые создает клиент API - задача клиента.

__`::TODO::`__ Максимальный размер тела запроса

__`::TODO::`__ Максимальный размер пакета с запросом

__`::TODO::`__ Ограничение длины URL

__`::TODO::`__ Ограничение длины значений в теле запроса

__`::TODO::`__ Допустимые предел числа ключей в корне объекта, выше которого рекомендуется делать вложения в структуре (как вариант, если есть 3 и более однородных по смыслу ключа - нужно их агрегировать в один объект)

# Процесс разработки API

Вход: Детализированная постановка задачи (Task) и методические рекомендации (Guidelines)

Шаг 1: Прототип SDK ([_пример_](https://gitlab.market.local/a.kolosov/evotor-cloud-java-sdk/tree/master/src))

Шаг 2: Коллективное ревью

Шаг 3: Тесты SDK и примеры данных _(JSON)_

Шаг 4: Повторное коллективное ревью

Шаг 5: Реализация

Шаг 6: Документирование _(включая спецификацию Open API)_

Шаг 7: Тестирование

Шаг 8: Развертывание

Шаг 9: Обратная связь от потребителей API

Шаг 10: Повторение шагов 1-9 _(опционально)_

Выход: API как Продукт
